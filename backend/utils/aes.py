#AES加密算法
import random #生成随机数
import base64 #base64编码
key=[85, 101, 226, 207, 83, 220, 52, 95, 244, 17, 18, 65, 40, 128, 148, 181]
iv= [49, 253, 107, 129, 93, 227, 250, 144, 222, 98, 243, 171, 50, 197, 46, 206]
#定义S盒
S_BOX = [
    [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76],
    [0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0],
    [0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15],
    [0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75],
    [0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84],
    [0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf],
    [0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8],
    [0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2],
    [0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73],
    [0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb],
    [0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79],
    [0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08],
    [0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a],
    [0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e],
    [0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf],
    [0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16]
]
#定义逆S盒
INV_S_BOX = [
    [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb],
    [0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb],
    [0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e],
    [0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25],
    [0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92],
    [0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84],
    [0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06],
    [0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b],
    [0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73],
    [0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e],
    [0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b],
    [0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4],
    [0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f],
    [0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef],
    [0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61],
    [0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]
]
#定义Rcon
RCON = [
    [0x00, 0x00, 0x00, 0x00],
    [0x01, 0x00, 0x00, 0x00],
    [0x02, 0x00, 0x00, 0x00],
    [0x04, 0x00, 0x00, 0x00],
    [0x08, 0x00, 0x00, 0x00],
    [0x10, 0x00, 0x00, 0x00],
    [0x20, 0x00, 0x00, 0x00],
    [0x40, 0x00, 0x00, 0x00],
    [0x80, 0x00, 0x00, 0x00],
    [0x1b, 0x00, 0x00, 0x00],
    [0x36, 0x00, 0x00, 0x00]
]
#定义密钥扩展
def key_expansion(key):
    expanded_key = [0] * 176
    for i in range(16):#密钥的前16个字节是原始密钥
        expanded_key[i] = key[i]
    for i in range(16, 176, 4):
        temp = expanded_key[i-4:i]#每次扩展4个字节
        if i % 16 == 0:#每16个字节扩展一次
            temp = temp[1:] + temp[:1]#循环左移
            for j in range(4):#字节替换
                temp[j] = S_BOX[temp[j] // 16][temp[j] % 16]#S盒
            temp[0] ^= RCON[i // 16][0]#轮常数
        for j in range(4):#扩展密钥
            expanded_key[i+j] = expanded_key[i+j-16] ^ temp[j]#异或
    return expanded_key
#定义字节替换
def sub_bytes(state):
    for i in range(16):
        state[i] = S_BOX[state[i] // 16][state[i] % 16]
    return state
#定义逆字节替换
def inv_sub_bytes(state):
    for i in range(16):
        state[i] = INV_S_BOX[state[i] // 16][state[i] % 16]
    return state
#定义行移位
def shift_rows(state):
    state[1], state[5], state[9], state[13] = state[5], state[9], state[13], state[1]
    state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]
    state[3], state[7], state[11], state[15] = state[15], state[3], state[7], state[11]
    return state
#定义逆行移位
def inv_shift_rows(state):
    state[1], state[5], state[9], state[13] = state[13], state[1], state[5], state[9]
    state[2], state[6], state[10], state[14] = state[10], state[14], state[2], state[6]
    state[3], state[7], state[11], state[15] = state[7], state[11], state[15], state[3]
    return state
#10进制数组转化为16进制数组
def dec_to_hex(state):
    for i in range(16):
        state[i]=hex(state[i])
    return state
#16进制数组转化为10进制数组
def hex_to_dec(state):
    for i in range(16):
        state[i]=int(str(state[i]),16)
    return state
#定义域GF(2^8)列混淆,增加密码的复杂性
def mix_columns(state):
    for i in range(0, 16, 4):
        a = [0, 0, 0, 0]  # a是列的副本
        b = [0, 0, 0, 0]  # b是a的副本，但每个元素都乘以2
        for j in range(4):
            a[j] = state[i + j]
            h = state[i + j] & 0x80  # 判断最高位是否为1
            b[j] = state[i + j] << 1  # 左移一位
            # 如果最高位为1，那么左移后需要异或上0x1b
            if h == 0x80:
                b[j] ^= 0x1b # 0x1b是多项式x^8 + x^4 + x^3 + x + 1
        # 更新列
        state[i] =( b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3])%256  # 2*a0 + 3*a1 + a2 + a3
        state[i + 1] =( a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3])%256  # a0 + 2*a1 + 3*a2 + a3
        state[i + 2] =( a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3] )%256 # a0 + a1 + 2*a2 + 3*a3
        state[i + 3] = (a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3])%256  # 3*a0 + a1 + a2 + 2*a3
    return state
#定义GF(2^8)乘法
def gmul(a, b):
    p = 0
    for counter in range(8): #8位
        if (b & 1) != 0:
            p ^= a
        hi_bit_set = a & 0x80 #判断最高位是否为1
        a <<= 1 #左移一位
        a &= 0xFF #保留8位
        if hi_bit_set != 0: #如果最高位为1，那么左移后需要异或上0x1b
            a ^= 0x1b #0x1b是多项式x^8 + x^4 + x^3 + x + 1
        b >>= 1
    return p
#定义域GF(2^8)逆列混淆
def inv_mix_columns(state):
    for i in range(0,16,4):
        temp = [0] * 4
        for j in range(4):
            temp[j] = state[i+j]
        state[i] = (gmul(0x0e, temp[0]) ^ gmul(0x0b, temp[1]) ^ gmul(0x0d, temp[2]) ^ gmul(0x09, temp[3])) % 256
        state[i+1] = (gmul(0x09, temp[0]) ^ gmul(0x0e, temp[1]) ^ gmul(0x0b, temp[2]) ^ gmul(0x0d, temp[3])) % 256
        state[i+2] = (gmul(0x0d, temp[0]) ^ gmul(0x09, temp[1]) ^ gmul(0x0e, temp[2]) ^ gmul(0x0b, temp[3])) % 256
        state[i+3] = (gmul(0x0b, temp[0]) ^ gmul(0x0d, temp[1]) ^ gmul(0x09, temp[2]) ^ gmul(0x0e, temp[3])) % 256
    return state
#定义轮密钥加
def add_round_key(state, round_key):
    for i in range(16):
        state[i] ^= round_key[i]
    return state
#定义AES加密128位
def aes_encrypt(plain_text, key):
    state = plain_text
    round_key = key_expansion(key)
    state = add_round_key(state, round_key[:16])#轮密钥加
    for i in range(16, 160, 16):
        state = sub_bytes(state)
        state = shift_rows(state)
        state = mix_columns(state)
        state = add_round_key(state, round_key[i:i+16])
    state = sub_bytes(state)
    state = shift_rows(state)
    state = add_round_key(state, round_key[160:])
    return state
#定义AES解密128位
def aes_decrypt(cipher_text, key):
    state = cipher_text
    round_key = key_expansion(key)
    state = add_round_key(state, round_key[160:])
    for i in range(144,0,-16):
        state = inv_shift_rows(state)
        state = inv_sub_bytes(state)
        state = add_round_key(state, round_key[i:i+16])
        state = inv_mix_columns(state)
    state = inv_shift_rows(state)
    state = inv_sub_bytes(state)
    state = add_round_key(state, round_key[:16])
    return state
#定义PKCS#7填充
def pkcs7_padding(data, block_size=16):
    pad_len = block_size - (len(data) % block_size)#
    data += ([pad_len] * pad_len) #使用pad_len的值作为填充的字节
    return data
#定义去除pkcs#7填充
def pkcs7_unpadding(data):
    pad_len = data[-1]#获取最后一个字节的值
    if pad_len < 1 or pad_len > 16:
        raise ValueError("超出有效范围")
    return data[:-pad_len]#去除填充
#定义CBC加密，并使用pkcs7填充
def cbc_encrypt(plain_text, key, iv):
    cipher_text = []
    previous_block = iv
    for i in range(0, len(plain_text), 16):
        block = plain_text[i:i+16]
        for j in range(16):
            block[j] ^= previous_block[j]#异或
        block = aes_encrypt(block, key)
        previous_block = block#更新previous_block
        cipher_text += block#拼接
    return cipher_text
#定义CBC解密
def cbc_decrypt(cipher_text, key, iv):
    plain_text = []
    previous_block = iv
    for i in range(0, len(cipher_text), 16):
        block = cipher_text[i:i+16]
        temp = block[:]#保存block
        decrypt_block = aes_decrypt(temp, key)
        for j in range(16):
            decrypt_block[j] ^= previous_block[j]#异或
        plain_text += decrypt_block#拼接
        previous_block = block#更新previous_block
    return plain_text
#定义字符串转字节列表
def string_to_bytes(string):
    byte_list = [ord(c) for c in string]
    return byte_list
#定义字节列表转字符串
def bytes_to_string(byte_list):
    return ''.join(chr(b) if 0 <= b <= 0x10FFFF else '' for b in byte_list)
#定义字节列表转字符串,为base64编码
def bytes_to_string_base64(byte_list):
    return base64.b64encode(bytes(byte_list)).decode('utf-8')
#定义加密
def encrypt(access_token):
    plain_text = pkcs7_padding(string_to_bytes(access_token))
    cipher_text = cbc_encrypt(plain_text, key, iv)
    cipher_text=bytes_to_string_base64(cipher_text)
    return cipher_text
#定义解密
def decrypt(cipher_text):
    cipher_text=base64.b64decode(cipher_text)
    cipher_text=list(cipher_text)
    plain_text = cbc_decrypt(cipher_text, key, iv)
    plain_text = pkcs7_unpadding(plain_text)
    plain_text = bytes_to_string(plain_text)
    return plain_text
#测试
if __name__ == '__main__':
    key=[85, 101, 226, 207, 83, 220, 52, 95, 244, 17, 18, 65, 40, 128, 148, 181]
    iv= [49, 253, 107, 129, 93, 227, 250, 144, 222, 98, 243, 171, 50, 197, 46, 206]
    plain_text = input("请输入明文:")
    cipher_text = encrypt(plain_text)
    print("密文(base64):",cipher_text)
    plain_text = decrypt(cipher_text)
    print("解密后明文:",plain_text)
    # access_token='hello.WGHTofHyalfhnvdjdkljskdjssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss'
    # plain_text = pkcs7_padding(string_to_bytes(access_token))
    # print("明文:",access_token)
    # print("密钥(base64):",bytes_to_string_base64(key))
    # print("iv(base64):",bytes_to_string_base64(iv))
    # cipher_text=cbc_encrypt(plain_text,key,iv)
    # print("密文(base64):",bytes_to_string_base64(cipher_text))
    # plain_text1=cbc_decrypt(cipher_text,key,iv)
    # plain_text2=pkcs7_unpadding(plain_text1)
    # print("解密后明文:",bytes_to_string(plain_text2))